<!DOCTYPE HTML>
<html lang="en" >
    <head><meta charset="UTF-8">
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"><title>API Gateway · tjufc&#39;s blog</title><meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="description" content="Build Jekyll site with the GitBook style.
"><meta name="generator" content="Jekyll (using style of GitBook 3.2.3)"><meta name="author" content="tjufc"><link rel="stylesheet" href="/gitbook/style.css">
<link rel="stylesheet" href="/gitbook/gitbook-plugin-fontsettings/website.css">
<link rel="stylesheet" href="/gitbook/gitbook-plugin-search-pro/search.css">

<link rel="stylesheet" href="/gitbook/rouge/colorful.css">

<meta name="HandheldFriendly" content="true"/>
<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black">
<link rel="apple-touch-icon-precomposed" sizes="152x152" href="/gitbook/images/apple-touch-icon-precomposed-152.png">
<link rel="shortcut icon" href="/gitbook/images/favicon.ico" type="image/x-icon">

<script>
    MathJax = {
        tex: {
            inlineMath: [['$', '$'], ['\\(', '\\)']]
        },
        svg: {
            fontCache: 'global'
        }
    };
</script>

            <link rel="prev" href="/jekyll/2019-04-29-license.html" />
        

        
    </head>
    <body>
        <div class="book"><div class="book-summary">
    <div id="book-search-input" role="search">
        <input type="text" placeholder="Type to search" />
    </div>
    <nav role="navigation">
        <ul class="summary">
            
            <li class="chapter" data-level="1.1" data-path="">
            
                <a href="/">
                    tjufc&#39;s blog
                </a>
            </li>

            <li class="divider"></li>

            

            
                
                <li class="chapter" data-level="1.1" data-path="/jekyll/2019-04-29-license.html">
                
                    <a href="/jekyll/2019-04-29-license.html">
                        License
                    </a>
                    
                        
                    
                </li>
            
                
                <li class="chapter active" data-level="1.2" data-path="/jekyll/2022-02-05-api-gateway.html">
                
                    <a href="/jekyll/2022-02-05-api-gateway.html">
                        API Gateway
                    </a>
                    
                        
                            <ul><li><a href="#api-gateway">API Gateway</a><ul><li><a href="#概述">概述</a></li><li><a href="#典型案例">典型案例</a></li><li><a href="#百度bfe">百度BFE</a><ul><li><a href="#概述-1">概述</a></li><li><a href="#源码结构梳理">源码结构梳理</a></li><li><a href="#模块插件机制">模块插件机制</a></li><li><a href="#流量转发">流量转发</a></li><li><a href="#条件表达式">条件表达式</a></li><li><a href="#监控">监控</a></li><li><a href="#日志">日志</a></li><li><a href="#其它">其它</a></li></ul></li><li><a href="#美团">美团</a><ul><li><a href="#概述-2">概述</a></li></ul></li><li><a href="#traefik">Traefik</a></li></ul></li></ul>

                        
                    
                </li>
            

            <li class="divider"></li>

            <li>
                <a href="https://github.com/sighingnow/jekyll-gitbook/fork" target="blank" class="gitbook-link">
                    Fork it Now!
                </a>
            </li>
        </ul>
    </nav>
</div><div class="book-body"><div class="body-inner">
    <div class="book-header" role="navigation">
        <!-- Title -->
        <h1>
            <i class="fa fa-circle-o-notch fa-spin"></i>
            
                <a href="." >API Gateway</a>
            
        </h1>
    </div>
    <div class="page-wrapper" tabindex="-1" role="main">
        <div class="page-inner">
            <div id="book-search-results">
                <div class="search-noresults">
                    <section class="normal markdown-section">

                        
                            <h1 id="/jekyll/api-gateway">API Gateway</h1>
                        

                        <ul>
  <li><a href="#api-gateway">API Gateway</a>
    <ul>
      <li><a href="#概述">概述</a></li>
      <li><a href="#典型案例">典型案例</a></li>
      <li><a href="#百度bfe">百度BFE</a>
        <ul>
          <li><a href="#概述-1">概述</a></li>
          <li><a href="#源码结构梳理">源码结构梳理</a></li>
          <li><a href="#模块插件机制">模块插件机制</a></li>
          <li><a href="#流量转发">流量转发</a></li>
          <li><a href="#条件表达式">条件表达式</a></li>
          <li><a href="#监控">监控</a></li>
          <li><a href="#日志">日志</a></li>
          <li><a href="#其它">其它</a></li>
        </ul>
      </li>
      <li><a href="#美团">美团</a>
        <ul>
          <li><a href="#概述-2">概述</a></li>
        </ul>
      </li>
      <li><a href="#traefik">Traefik</a></li>
    </ul>
  </li>
</ul>

<h1 id="api-gateway">API Gateway</h1>

<h2 id="概述">概述</h2>

<p>以下是nginx官网对API Gateway的一段介绍：
<a href="https://www.nginx.com/learn/api-gateway/">refer</a></p>

<blockquote>
  <p>An API gateway is the conductor that organizes the requests being processed by the microservices architecture to create a simplified experience for the user. 面向微服务。<br />
It’s a translator, taking a client’s many requests and turning them into just one, to reduce the number of round trips between the client and application. 服务(接口？)编排能力。<br />
An API gateway is set up in front of the microservices and becomes the entry point for every new request being executed by the app. It simplifies both the client implementations and the microservices app. 接入层。<br /></p>
</blockquote>

<p><span style="display:block;text-align:center"><img src="/images/api_gateway/nginx_gw.png" alt="nginx api gateway" height="100%" width="100%" /></span></p>
<div style="font-size:14px;text-align:center">Nginx for API Gateway</div>

<h2 id="典型案例">典型案例</h2>

<ul>
  <li>百度<a href="https://github.com/bfenetworks/bfe">BFE</a></li>
  <li>美团
    <ul>
      <li><a href="https://tech.meituan.com/2018/09/06/oceanus-custom-traffic-routing.html">Oceanus</a></li>
      <li><a href="https://mp.weixin.qq.com/s/iITqdIiHi3XGKq6u6FRVdg">Shepherd</a></li>
    </ul>
  </li>
  <li><a href="https://github.com/traefik/traefik">Traefik</a></li>
  <li><a href="https://github.com/luraproject/lura">Lura</a> 看起来主要是用来做服务编排的。</li>
</ul>

<h2 id="百度bfe">百度BFE</h2>

<p>学习内容：原理；（按模块）设计思想、源码</p>

<p>参考材料：</p>

<ul>
  <li><a href="https://github.com/baidu/bfe-book">《深入理解BFE》</a></li>
</ul>

<h3 id="概述-1">概述</h3>

<ul>
  <li>定位：百度内部的七层负载均衡接入层</li>
  <li>功能：接入和转发、流量调度、WAF、数据分析</li>
  <li>接入层技术发展
    <ul>
      <li>HTTPS：证书维护、性能</li>
      <li>安全：DDoS攻击；防御规则检查；计算资源；0 day场景。</li>
      <li>数据：接入层的优势？后端延迟、错误；用户所有的流量数据。</li>
      <li>控制系统：自动化、智能化。云原生化。</li>
    </ul>
  </li>
  <li>负载均衡：四层负载均衡(BGW) VS 七层负载均衡(BFE)</li>
</ul>

<p><span style="display:block;text-align:center"><img src="/images/bfe/百度的负载均衡架构.png" alt="百度的负载均衡架构" height="50%" width="50%" /></span></p>
<div style="font-size:14px;text-align:center">百度的负载均衡架构</div>

<h3 id="源码结构梳理">源码结构梳理</h3>

<p><span style="display:block;text-align:center"><img src="/images/bfe/uml_bfe.png" alt="bfe源码结构" /></span></p>
<div style="font-size:14px;text-align:center">bfe源码结构</div>

<p><code class="language-plaintext highlighter-rouge">BfeServer</code>顶层对象</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">BfeServer</code>对应一个监听协程，每个监听协程针对每个请求开启1个处理协程。单个bfe进程可以配置多个<code class="language-plaintext highlighter-rouge">BfeServer</code>。</li>
  <li><code class="language-plaintext highlighter-rouge">BfeServer</code>通过<code class="language-plaintext highlighter-rouge">WaitGroup</code>控制请求处理协程，并实现优雅重启。</li>
  <li><code class="language-plaintext highlighter-rouge">Serve()</code>方法负责执行整个请求处理及响应。其中，<code class="language-plaintext highlighter-rouge">conn</code>对象负责实现基础网络功能，<code class="language-plaintext highlighter-rouge">ReverseProxy</code>对象负责实现路由、负载均衡等核心功能。完整流程详见<a href="https://github.com/baidu/bfe-book/blob/version1/implementation/life_of_a_request/life_of_a_request.md">请求处理流程及响应</a>一节，代码参见<code class="language-plaintext highlighter-rouge">ReverseProxy.ServeHTTP()</code>。</li>
  <li><code class="language-plaintext highlighter-rouge">BfeServer</code>依赖回调框架能力(<code class="language-plaintext highlighter-rouge">bfe_module</code>包)，注册并顺序执行回调链，实现请求的定制化处理。</li>
  <li><code class="language-plaintext highlighter-rouge">bfe_basic.Request</code>和<code class="language-plaintext highlighter-rouge">bfe_basic.Response</code>：相当于请求上下文，特别是前者，在其它的web框架中我们也可以看到命名类似于<em>Context</em>的对象。它们贯穿了整个<code class="language-plaintext highlighter-rouge">conn</code>的生命周期，我们在这个协程的任何地方访问它都是最低成本的。</li>
</ul>

<h3 id="模块插件机制">模块插件机制</h3>

<p><strong>准备</strong></p>

<ul>
  <li>参考章节：
    <ul>
      <li><a href="https://github.com/baidu/bfe-book/blob/version1/design/module/module.md">模块插件机制</a></li>
      <li><a href="https://github.com/baidu/bfe-book/blob/version1/implementation/model_framework/model_framework.md">模块框架</a></li>
      <li><a href="https://github.com/baidu/bfe-book/blob/version1/develop/how_to_write_module/how_to_write_module.md">如何开发BFE扩展模块</a></li>
    </ul>
  </li>
  <li>代码模块
    <ul>
      <li><code class="language-plaintext highlighter-rouge">bfe_module</code></li>
      <li><code class="language-plaintext highlighter-rouge">bfe_modules</code>、<code class="language-plaintext highlighter-rouge">bfe_modules.mod_waf</code></li>
    </ul>
  </li>
</ul>

<p><strong>回调模型</strong></p>

<p>BFE通过<em>回调</em>来执行插件功能。</p>

<ul>
  <li>回调框架(BfeCallbacks)</li>
  <li>回调点(CallbackPoint)：单个请求维度定义了9个回调点。</li>
  <li>回调链(HandlerList)：实现上是个链表。</li>
  <li>回调(接口)类型：<code class="language-plaintext highlighter-rouge">RequestFilter</code>等5个回调接口。</li>
  <li>回调返回类型(没定义，暂且称之为HandlerReturnType)</li>
</ul>

<p>以下是<code class="language-plaintext highlighter-rouge">ReverseProxy.ServeHTTP</code>请求处理流程中，某个回调点的代码：</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code>	<span class="c">// ...</span>

	<span class="c">// Callback for HandleBeforeLocation</span>
	<span class="c">// srv.CallBacks是回调框架BfeCallbacks对象</span>
	<span class="c">// 获取回调点HandleBeforeLocation对应的回调链</span>
	<span class="n">hl</span> <span class="o">=</span> <span class="n">srv</span><span class="o">.</span><span class="n">CallBacks</span><span class="o">.</span><span class="n">GetHandlerList</span><span class="p">(</span><span class="n">bfe_module</span><span class="o">.</span><span class="n">HandleBeforeLocation</span><span class="p">)</span>
	<span class="k">if</span> <span class="n">hl</span> <span class="o">!=</span> <span class="no">nil</span> <span class="p">{</span>
		<span class="c">// 依次执行回调(函数)</span>
		<span class="c">// 逻辑上，在特定回调点有特定的回调(接口)类型</span>
		<span class="n">retVal</span><span class="p">,</span> <span class="n">res</span> <span class="o">=</span> <span class="n">hl</span><span class="o">.</span><span class="n">FilterRequest</span><span class="p">(</span><span class="n">basicReq</span><span class="p">)</span>
		<span class="n">basicReq</span><span class="o">.</span><span class="n">HttpResponse</span> <span class="o">=</span> <span class="n">res</span>
		<span class="c">// 根据回调返回类型进行处理</span>
		<span class="k">switch</span> <span class="n">retVal</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">bfe_module</span><span class="o">.</span><span class="n">BfeHandlerClose</span><span class="o">:</span>
			<span class="c">// close the connection directly (with no response)</span>
			<span class="n">action</span> <span class="o">=</span> <span class="n">closeDirectly</span>
			<span class="k">return</span>
		<span class="k">case</span> <span class="n">bfe_module</span><span class="o">.</span><span class="n">BfeHandlerFinish</span><span class="o">:</span>
			<span class="c">// close the connection after response</span>
			<span class="n">action</span> <span class="o">=</span> <span class="n">closeAfterReply</span>
			<span class="n">basicReq</span><span class="o">.</span><span class="n">BfeStatusCode</span> <span class="o">=</span> <span class="n">bfe_http</span><span class="o">.</span><span class="n">StatusInternalServerError</span>
			<span class="k">return</span>
		<span class="k">case</span> <span class="n">bfe_module</span><span class="o">.</span><span class="n">BfeHandlerRedirect</span><span class="o">:</span>
			<span class="c">// ...</span>
</code></pre></div></div>

<p>回调函数的添加实现(<code class="language-plaintext highlighter-rouge">AcceptFilter</code>示例)：</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">// AddAcceptFilter adds accept filter to handler list.</span>
<span class="k">func</span> <span class="p">(</span><span class="n">hl</span> <span class="o">*</span><span class="n">HandlerList</span><span class="p">)</span> <span class="n">AddAcceptFilter</span><span class="p">(</span><span class="n">f</span> <span class="k">interface</span><span class="p">{})</span> <span class="kt">error</span> <span class="p">{</span>
	<span class="n">callback</span><span class="p">,</span> <span class="n">ok</span> <span class="o">:=</span> <span class="n">f</span><span class="o">.</span><span class="p">(</span><span class="k">func</span><span class="p">(</span><span class="n">session</span> <span class="o">*</span><span class="n">bfe_basic</span><span class="o">.</span><span class="n">Session</span><span class="p">)</span> <span class="kt">int</span><span class="p">)</span>
	<span class="k">if</span> <span class="o">!</span><span class="n">ok</span> <span class="p">{</span>
		<span class="k">return</span> <span class="n">fmt</span><span class="o">.</span><span class="n">Errorf</span><span class="p">(</span><span class="s">"AddAcceptFilter():invalid callback func"</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="n">hl</span><span class="o">.</span><span class="n">handlers</span><span class="o">.</span><span class="n">PushBack</span><span class="p">(</span><span class="n">NewAcceptFilter</span><span class="p">(</span><span class="n">callback</span><span class="p">))</span>
	<span class="k">return</span> <span class="no">nil</span>
<span class="p">}</span>
</code></pre></div></div>

<p>上述的回调模型实现了模块可插拔，那么具体的功能模块该如何实现呢？我们继续来看。</p>

<p><strong>模块</strong></p>

<p>我们以非常重要的waf模块为例，深入研究一下模块内部的实现原理(<a href="https://zhuanlan.zhihu.com/p/97396469">WAF简介</a>)。这部分内容可以按照以下3个部分进行梳理：</p>

<ul>
  <li>模块配置</li>
  <li>回调的注册与实现</li>
  <li>模块状态</li>
</ul>

<p>waf模块配置示例：</p>

<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="w">
    </span><span class="nl">"Version"</span><span class="p">:</span><span class="w"> </span><span class="s2">"2019-12-10184356"</span><span class="p">,</span><span class="w">
    </span><span class="nl">"Config"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
        </span><span class="nl">"example_product"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="w">
            </span><span class="p">{</span><span class="w">
                </span><span class="nl">"Cond"</span><span class="p">:</span><span class="w"> </span><span class="s2">"req_path_prefix_in(</span><span class="se">\"</span><span class="s2">/rewrite</span><span class="se">\"</span><span class="s2">, false)"</span><span class="p">,</span><span class="w">
                </span><span class="nl">"BlockRules"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="w">
	            </span><span class="s2">"RuleBashCmd"</span><span class="w">
                </span><span class="p">]</span><span class="w">
            </span><span class="p">}</span><span class="w">
        </span><span class="p">]</span><span class="w">
    </span><span class="p">}</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<p>大部分的模块功能都可以拆分为2部分，即：条件(<code class="language-plaintext highlighter-rouge">Cond</code>)、动作(<code class="language-plaintext highlighter-rouge">BlockRules</code>，在其它模块也叫<code class="language-plaintext highlighter-rouge">Actions</code>等)。那么，一个模块的逻辑可以描述为：如果命中条件，就执行动作。</p>

<p>waf模块实现了<code class="language-plaintext highlighter-rouge">bfe_module.RequestFilter</code>回调：</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="p">(</span><span class="n">m</span> <span class="o">*</span><span class="n">ModuleWaf</span><span class="p">)</span> <span class="n">handleWaf</span><span class="p">(</span><span class="n">req</span> <span class="o">*</span><span class="n">bfe_basic</span><span class="o">.</span><span class="n">Request</span><span class="p">)</span> <span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="o">*</span><span class="n">bfe_http</span><span class="o">.</span><span class="n">Response</span><span class="p">)</span> <span class="p">{</span>
	<span class="c">// 获取RuleList</span>
	<span class="n">rules</span><span class="p">,</span> <span class="n">ok</span> <span class="o">:=</span> <span class="n">m</span><span class="o">.</span><span class="n">ruleTable</span><span class="o">.</span><span class="n">Search</span><span class="p">(</span><span class="n">req</span><span class="o">.</span><span class="n">Route</span><span class="o">.</span><span class="n">Product</span><span class="p">)</span>
	<span class="k">if</span> <span class="o">!</span><span class="n">ok</span> <span class="p">{</span>
		<span class="k">return</span> <span class="n">bfe_module</span><span class="o">.</span><span class="n">BfeHandlerGoOn</span><span class="p">,</span> <span class="no">nil</span>
	<span class="p">}</span>
	<span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">rule</span> <span class="o">:=</span> <span class="k">range</span> <span class="o">*</span><span class="n">rules</span> <span class="p">{</span>
		<span class="c">// 首先，判断条件是否命中</span>
		<span class="k">if</span> <span class="o">!</span><span class="n">rule</span><span class="o">.</span><span class="n">Cond</span><span class="o">.</span><span class="n">Match</span><span class="p">(</span><span class="n">req</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">continue</span>
		<span class="p">}</span>
		<span class="n">m</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">CheckedReq</span><span class="o">.</span><span class="n">Inc</span><span class="p">(</span><span class="m">1</span><span class="p">)</span>
		<span class="c">// BlockRules - 拦截模式</span>
		<span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">blockRule</span> <span class="o">:=</span> <span class="k">range</span> <span class="n">rule</span><span class="o">.</span><span class="n">BlockRules</span> <span class="p">{</span>
			<span class="n">blocked</span><span class="p">,</span> <span class="n">err</span> <span class="o">:=</span> <span class="n">m</span><span class="o">.</span><span class="n">handler</span><span class="o">.</span><span class="n">HandleBlockJob</span><span class="p">(</span><span class="n">blockRule</span><span class="p">,</span> <span class="n">req</span><span class="p">)</span>
			<span class="k">if</span> <span class="n">err</span> <span class="o">!=</span> <span class="no">nil</span> <span class="p">{</span>
				<span class="n">m</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">BlockedRuleError</span><span class="o">.</span><span class="n">Inc</span><span class="p">(</span><span class="m">1</span><span class="p">)</span>
				<span class="n">log</span><span class="o">.</span><span class="n">Logger</span><span class="o">.</span><span class="n">Debug</span><span class="p">(</span><span class="s">"ModuleWaf.handleWaf() block job err=%v, rule=%s"</span><span class="p">,</span> <span class="n">err</span><span class="p">,</span> <span class="n">blockRule</span><span class="p">)</span>
				<span class="k">continue</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="n">blocked</span> <span class="p">{</span>
				<span class="n">req</span><span class="o">.</span><span class="n">ErrCode</span> <span class="o">=</span> <span class="n">ErrWaf</span>
				<span class="n">m</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">HitBlockedReq</span><span class="o">.</span><span class="n">Inc</span><span class="p">(</span><span class="m">1</span><span class="p">)</span>
				<span class="k">return</span> <span class="n">bfe_module</span><span class="o">.</span><span class="n">BfeHandlerFinish</span><span class="p">,</span> <span class="no">nil</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="c">// CheckRules - 观察模式</span>
		<span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">checkRule</span> <span class="o">:=</span> <span class="k">range</span> <span class="n">rule</span><span class="o">.</span><span class="n">CheckRules</span> <span class="p">{</span>
			<span class="c">// ...</span>
		<span class="p">}</span>
		<span class="k">break</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">bfe_module</span><span class="o">.</span><span class="n">BfeHandlerGoOn</span><span class="p">,</span> <span class="no">nil</span>
<span class="p">}</span>
</code></pre></div></div>

<p>几个点：</p>

<ul>
  <li>用到了我们之前介绍过的<a href="#条件表达式">条件表达式</a></li>
  <li>waf规则的处理分为<em>拦截模式</em>(<code class="language-plaintext highlighter-rouge">BlockRules</code>)和<em>观察模式</em>(CheckRules)。这是因为waf规则上线通常需要先开启观察模式验证，后开启拦截模式拦截攻击流量。</li>
  <li>waf模块状态<code class="language-plaintext highlighter-rouge">ModuleWafState</code>主要记录了各种规则命中的数据，用于统计。这个信息也非常重要，往往需要采集到后台进行统一监控。详见<a href="#监控">监控</a>一节。</li>
</ul>

<p>模块的注册是<code class="language-plaintext highlighter-rouge">bfe_module.BfeModule</code>接口中<code class="language-plaintext highlighter-rouge">Init</code>规定的，waf模块出了注册回调，还添加了监控。</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="p">(</span><span class="n">m</span> <span class="o">*</span><span class="n">ModuleWaf</span><span class="p">)</span> <span class="n">Init</span><span class="p">(</span><span class="n">cbs</span> <span class="o">*</span><span class="n">bfe_module</span><span class="o">.</span><span class="n">BfeCallbacks</span><span class="p">,</span> <span class="n">whs</span> <span class="o">*</span><span class="n">web_monitor</span><span class="o">.</span><span class="n">WebHandlers</span><span class="p">,</span> <span class="n">cr</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
	<span class="c">// ...</span>

	<span class="c">// 回调注册</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">cbs</span><span class="o">.</span><span class="n">AddFilter</span><span class="p">(</span><span class="n">bfe_module</span><span class="o">.</span><span class="n">HandleFoundProduct</span><span class="p">,</span> <span class="n">m</span><span class="o">.</span><span class="n">handleWaf</span><span class="p">)</span>
	<span class="k">if</span> <span class="n">err</span> <span class="o">!=</span> <span class="no">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="n">fmt</span><span class="o">.</span><span class="n">Errorf</span><span class="p">(</span><span class="s">"%s.Init(): AddFilter(m.handleWaf): %v"</span><span class="p">,</span> <span class="n">m</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">err</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">web_monitor</span><span class="o">.</span><span class="n">RegisterHandlers</span><span class="p">(</span><span class="n">whs</span><span class="p">,</span> <span class="n">web_monitor</span><span class="o">.</span><span class="n">WebHandleMonitor</span><span class="p">,</span> <span class="n">m</span><span class="o">.</span><span class="n">monitorHandlers</span><span class="p">())</span>
	<span class="k">if</span> <span class="n">err</span> <span class="o">!=</span> <span class="no">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="n">fmt</span><span class="o">.</span><span class="n">Errorf</span><span class="p">(</span><span class="s">"%s.Init(): RegisterHandlers(m.monitorHandlers): %v"</span><span class="p">,</span> <span class="n">m</span><span class="o">.</span><span class="n">Name</span><span class="p">(),</span> <span class="n">err</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="c">// ...</span>
<span class="p">}</span>
</code></pre></div></div>

<p><strong>实现细节</strong></p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">bfe_module.HandlerList</code>内表示回调类型的类型成员事实上并没有什么用。回调接口类型是通过<code class="language-plaintext highlighter-rouge">switch type {}</code>动态判断的。</li>
  <li><code class="language-plaintext highlighter-rouge">mod_waf.wafRule</code>和<code class="language-plaintext highlighter-rouge">mod_waf.WafRule</code>的区别：命名接近。前者负责检查条件是否命中，后者负责实现动作执行。</li>
</ul>

<h3 id="流量转发">流量转发</h3>

<p><strong>转发模型</strong></p>

<p>参考章节：<a href="https://github.com/baidu/bfe-book/blob/version1/design/model/model.md">BFE的转发模型</a></p>

<ul>
  <li>租户(Tenant/Product)：大致上，一个域名对应一个租户。百度内部可能叫“产品线”。</li>
  <li>集群(Cluster)：一个租户可以对应多个集群，一个租户维护一个路由转发表。一个集群一般按照不同的IDC再划分多个子集群。</li>
  <li>实例：<code class="language-plaintext highlighter-rouge">ip:port</code></li>
</ul>

<p><strong>实现机制</strong></p>

<p>设计为2个核心能力</p>

<ul>
  <li><a href="https://github.com/baidu/bfe-book/blob/version1/implementation/routing/routing.md">请求路由</a>：负责通过域名、Vip、path等特征，根据路由规则，获取租户-&gt;集群。代码上对应<code class="language-plaintext highlighter-rouge">bfe_route</code>包，规则的解析则依赖<code class="language-plaintext highlighter-rouge">bfe_route_conf</code>包。</li>
  <li><a href="https://github.com/baidu/bfe-book/blob/version1/implementation/balancing/balancing.md">负载均衡</a>：已知下游集群的情况下，根据负载均衡策略，获取子集群-&gt;实例。代码上对应<code class="language-plaintext highlighter-rouge">bfe_balancer</code>包。</li>
</ul>

<p><strong>实现细节</strong></p>

<ul>
  <li>(根据域名)获取租户 <code class="language-plaintext highlighter-rouge">HostTable.findHostRoute</code></li>
</ul>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="p">(</span><span class="n">t</span> <span class="o">*</span><span class="n">HostTable</span><span class="p">)</span> <span class="n">findHostRoute</span><span class="p">(</span><span class="n">host</span> <span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="n">route</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="c">// ...</span>
	<span class="n">match</span><span class="p">,</span> <span class="n">ok</span> <span class="o">:=</span> <span class="n">t</span><span class="o">.</span><span class="n">hostTrie</span><span class="o">.</span><span class="n">Get</span><span class="p">(</span><span class="n">strings</span><span class="o">.</span><span class="n">Split</span><span class="p">(</span><span class="n">string_reverse</span><span class="o">.</span><span class="n">ReverseFqdnHost</span><span class="p">(</span><span class="n">hostnameStrip</span><span class="p">(</span><span class="n">host</span><span class="p">)),</span> <span class="s">"."</span><span class="p">))</span>
	<span class="k">if</span> <span class="n">ok</span> <span class="p">{</span>
		<span class="c">// get route success, return</span>
		<span class="k">return</span> <span class="n">match</span><span class="o">.</span><span class="p">(</span><span class="n">route</span><span class="p">),</span> <span class="no">nil</span>
	<span class="p">}</span>
  <span class="c">// ...</span>
<span class="p">}</span>
</code></pre></div></div>

<p>使用了一棵域名<a href="https://zhuanlan.zhihu.com/p/28891541">前缀树</a>来查找，从根节点到叶子节点为一个完整域名。从根节点往下依次是各级<a href="https://baike.baidu.com/item/%E9%A1%B6%E7%BA%A7%E5%9F%9F%E5%90%8D/2152551">域名</a>，到了叶子节点则是租户。</p>

<p>前缀树的结构：和普通的树区别在于节点的children使用了一个映射，key为前缀。</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="n">trieChildren</span> <span class="k">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="o">*</span><span class="n">Trie</span>

<span class="k">type</span> <span class="n">Trie</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="n">Entry</span>      <span class="k">interface</span><span class="p">{}</span>
	<span class="n">SplatEntry</span> <span class="k">interface</span><span class="p">{}</span> <span class="c">// to match xxx.xxx.*</span>
	<span class="n">Children</span>   <span class="n">trieChildren</span>
<span class="p">}</span>
</code></pre></div></div>

<p>根据完整域名(<code class="language-plaintext highlighter-rouge">path</code>)查找租户的算法：</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="p">(</span><span class="n">t</span> <span class="o">*</span><span class="n">Trie</span><span class="p">)</span> <span class="n">Get</span><span class="p">(</span><span class="n">path</span> <span class="p">[]</span><span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="n">entry</span> <span class="k">interface</span><span class="p">{},</span> <span class="n">ok</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>
	<span class="c">// 递归终止条件</span>
	<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">path</span><span class="p">)</span> <span class="o">==</span> <span class="m">0</span> <span class="p">{</span>
		<span class="k">return</span> <span class="n">t</span><span class="o">.</span><span class="n">getEntry</span><span class="p">()</span>
	<span class="p">}</span>

	<span class="c">// key是当前前缀</span>
	<span class="n">key</span> <span class="o">:=</span> <span class="n">path</span><span class="p">[</span><span class="m">0</span><span class="p">]</span>
	<span class="c">// newPath做为递归查找的输入路径</span>
	<span class="n">newPath</span> <span class="o">:=</span> <span class="n">path</span><span class="p">[</span><span class="m">1</span><span class="o">:</span><span class="p">]</span>

	<span class="n">res</span><span class="p">,</span> <span class="n">ok</span> <span class="o">:=</span> <span class="n">t</span><span class="o">.</span><span class="n">Children</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
	<span class="k">if</span> <span class="n">ok</span> <span class="p">{</span>
		<span class="c">// 递归查找</span>
		<span class="n">entry</span><span class="p">,</span> <span class="n">ok</span> <span class="o">=</span> <span class="n">res</span><span class="o">.</span><span class="n">Get</span><span class="p">(</span><span class="n">newPath</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="c">// ...</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>获取集群 <code class="language-plaintext highlighter-rouge">HostTable.LookupCluster</code></li>
</ul>

<p>路由规则的检查和动作执行代码如下：</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">// LookupCluster find clusterName with given request.</span>
<span class="k">func</span> <span class="p">(</span><span class="n">t</span> <span class="o">*</span><span class="n">HostTable</span><span class="p">)</span> <span class="n">LookupCluster</span><span class="p">(</span><span class="n">req</span> <span class="o">*</span><span class="n">bfe_basic</span><span class="o">.</span><span class="n">Request</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
	<span class="c">// match advanced route rules 获取路由规则表</span>
	<span class="n">rules</span><span class="p">,</span> <span class="n">ok</span> <span class="o">:=</span> <span class="n">t</span><span class="o">.</span><span class="n">productAdvancedRouteTable</span><span class="p">[</span><span class="n">req</span><span class="o">.</span><span class="n">Route</span><span class="o">.</span><span class="n">Product</span><span class="p">]</span>
	<span class="k">if</span> <span class="o">!</span><span class="n">ok</span> <span class="p">{</span>
		<span class="n">req</span><span class="o">.</span><span class="n">Route</span><span class="o">.</span><span class="n">ClusterName</span> <span class="o">=</span> <span class="s">""</span>
		<span class="n">req</span><span class="o">.</span><span class="n">Route</span><span class="o">.</span><span class="n">Error</span> <span class="o">=</span> <span class="n">ErrNoProductRule</span>
		<span class="k">return</span> <span class="n">req</span><span class="o">.</span><span class="n">Route</span><span class="o">.</span><span class="n">Error</span>
	<span class="p">}</span>

	<span class="c">// matching route rules 规则检查</span>
	<span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">rule</span> <span class="o">:=</span> <span class="k">range</span> <span class="n">rules</span> <span class="p">{</span>
		<span class="c">// 条件表达式描述的规则</span>
		<span class="k">if</span> <span class="n">rule</span><span class="o">.</span><span class="n">Cond</span><span class="o">.</span><span class="n">Match</span><span class="p">(</span><span class="n">req</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">clusterName</span> <span class="o">=</span> <span class="n">rule</span><span class="o">.</span><span class="n">ClusterName</span>
			<span class="k">break</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="c">// ...</span>
<span class="p">}</span>
</code></pre></div></div>

<p>可见，<code class="language-plaintext highlighter-rouge">productAdvancedRouteTable</code>中预先(显然是在server初始化阶段)注册了一些列分流条件，在这里根据请求(参数)进行逐个进行判断，直至找到符合条件的集群。
关于分流条件的实现细节，详见<a href="#条件表达式">条件表达式</a>一节。</p>

<h3 id="条件表达式">条件表达式</h3>

<p><strong>准备</strong></p>

<ul>
  <li>参考章节：<a href="https://github.com/baidu/bfe-book/blob/version1/design/route/route.md">BFE的路由转发机制—条件表达式</a></li>
  <li>代码模块：<code class="language-plaintext highlighter-rouge">bfe_basic/condition</code></li>
  <li>背景知识：<a href="https://juejin.cn/post/6844904035271573511">AST(抽象语法树)</a></li>
</ul>

<p><strong>实现机制</strong></p>

<p>如书中所述：</p>

<blockquote>
  <p>条件表达式在BFE的内部数据结构，是一个中缀表达式形式的二叉树。二叉树的非叶子节点代表了操作符。叶子节点代表条件原语。</p>
</blockquote>

<p><span style="display:block;text-align:center"><img src="/images/bfe/BFE条件表达式.png" alt="BFE条件表达式" height="80%" width="80%" /></span></p>
<div style="font-size:14px;text-align:center">BFE条件表达式实现机制</div>

<p>条件表达式对于用户相当于一套语言，底层引擎需要支持对这套语言的<em>编译</em>(<em>解释</em>)。这类问题往往通过AST来解决。</p>

<p>条件表达式的编译流程实现：</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="n">Build</span><span class="p">(</span><span class="n">condStr</span> <span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="n">Condition</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="c">// 词法解析&amp;语法解析，生成语法树</span>
	<span class="n">node</span><span class="p">,</span> <span class="n">identList</span><span class="p">,</span> <span class="n">err</span> <span class="o">:=</span> <span class="n">parser</span><span class="o">.</span><span class="n">Parse</span><span class="p">(</span><span class="n">condStr</span><span class="p">)</span>
	<span class="k">if</span> <span class="n">err</span> <span class="o">!=</span> <span class="no">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="no">nil</span><span class="p">,</span> <span class="n">err</span>
	<span class="p">}</span>

	<span class="c">// ...</span>

	<span class="c">// 构建执行树</span>
	<span class="k">return</span> <span class="n">build</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<p>主要包括2个步骤：</p>

<ul>
  <li>词法解析&amp;语法解析，生成语法树。以下简称<em>分析</em></li>
  <li>构建执行树。以下简称<em>生成</em></li>
</ul>

<p>其中，构建执行树(<code class="language-plaintext highlighter-rouge">build(node)</code>)的实现：</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="n">build</span><span class="p">(</span><span class="n">node</span> <span class="n">parser</span><span class="o">.</span><span class="n">Node</span><span class="p">)</span> <span class="p">(</span><span class="n">Condition</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">switch</span> <span class="n">n</span> <span class="o">:=</span> <span class="n">node</span><span class="o">.</span><span class="p">(</span><span class="k">type</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="o">*</span><span class="n">parser</span><span class="o">.</span><span class="n">CallExpr</span><span class="o">:</span>
		<span class="k">return</span> <span class="n">buildPrimitive</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
	<span class="k">case</span> <span class="o">*</span><span class="n">parser</span><span class="o">.</span><span class="n">UnaryExpr</span><span class="o">:</span>
		<span class="k">return</span> <span class="n">buildUnary</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
	<span class="k">case</span> <span class="o">*</span><span class="n">parser</span><span class="o">.</span><span class="n">BinaryExpr</span><span class="o">:</span>
		<span class="k">return</span> <span class="n">buildBinary</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
	<span class="k">case</span> <span class="o">*</span><span class="n">parser</span><span class="o">.</span><span class="n">ParenExpr</span><span class="o">:</span>
		<span class="k">return</span> <span class="n">build</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">X</span><span class="p">)</span>
	<span class="k">default</span><span class="o">:</span>
		<span class="k">return</span> <span class="no">nil</span><span class="p">,</span> <span class="n">fmt</span><span class="o">.</span><span class="n">Errorf</span><span class="p">(</span><span class="s">"unsupported node %s"</span><span class="p">,</span> <span class="n">node</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>可见，这棵AST的节点被分为了3类：</p>

<ul>
  <li><strong>叶子节点——原语</strong>：这类节点包含可以直接执行的<em>条件原语</em>。<em>分析</em>环节中将节点实例化为<code class="language-plaintext highlighter-rouge">parser.CallExpr</code>类型；<em>生成</em>环节实例化为<code class="language-plaintext highlighter-rouge">condition.PrimitiveCond</code>类型。</li>
  <li><strong>叶子结点—一元运算</strong>：这类节点需要在<em>条件原语</em>的基础上，进行一次一元逻辑运算，例如：<code class="language-plaintext highlighter-rouge">非</code>。<em>分析</em>环节对应<code class="language-plaintext highlighter-rouge">parser.UnaryExpr</code>，<em>生成</em>环节对应<code class="language-plaintext highlighter-rouge">condition.UnaryCond</code>。</li>
  <li><strong>非叶子结点</strong>：这类节点需要对左右2个子节点，进行一次二元逻辑运算，例如：<code class="language-plaintext highlighter-rouge">与/或/非</code>。<em>分析</em>环节中实例化为<code class="language-plaintext highlighter-rouge">parser.BinaryExpr</code>，<em>生成</em>环节中实例化为<code class="language-plaintext highlighter-rouge">parser.BinaryCond</code>。</li>
</ul>

<p><strong>实现细节</strong></p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">parser</code>包<em>分析</em>部分的代码看起来像是基于<code class="language-plaintext highlighter-rouge">go</code>包改造的。</li>
  <li><em>条件原语</em>的实现：<code class="language-plaintext highlighter-rouge">condition.PrimitiveCond</code>又被拆分成<code class="language-plaintext highlighter-rouge">Matcher</code>和<code class="language-plaintext highlighter-rouge">Fetcher</code>的组合，它们分别负责参数的获取和匹配。这样可以方便将已有的对象迅速组合出新的原语。</li>
</ul>

<p>例如：</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">// buildPrimitive builds primitive from PrimitiveCondExpr.</span>
<span class="c">// if failed, b.err is set to err, return Condition is nil</span>
<span class="c">// if success, b.err is nil</span>
<span class="k">func</span> <span class="n">buildPrimitive</span><span class="p">(</span><span class="n">node</span> <span class="o">*</span><span class="n">parser</span><span class="o">.</span><span class="n">CallExpr</span><span class="p">)</span> <span class="p">(</span><span class="n">Condition</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">switch</span> <span class="n">node</span><span class="o">.</span><span class="n">Fun</span><span class="o">.</span><span class="n">Name</span> <span class="p">{</span>
	<span class="k">case</span> <span class="s">"default_t"</span><span class="o">:</span>
		<span class="k">return</span> <span class="o">&amp;</span><span class="n">DefaultTrueCond</span><span class="p">{},</span> <span class="no">nil</span>
	<span class="c">// ...</span>
	<span class="k">case</span> <span class="s">"req_vip_in"</span><span class="o">:</span>
		<span class="n">matcher</span><span class="p">,</span> <span class="n">err</span> <span class="o">:=</span> <span class="n">NewIpInMatcher</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">Args</span><span class="p">[</span><span class="m">0</span><span class="p">]</span><span class="o">.</span><span class="n">Value</span><span class="p">)</span>
		<span class="k">if</span> <span class="n">err</span> <span class="o">!=</span> <span class="no">nil</span> <span class="p">{</span>
			<span class="k">return</span> <span class="no">nil</span><span class="p">,</span> <span class="n">err</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="o">&amp;</span><span class="n">PrimitiveCond</span><span class="p">{</span>
			<span class="n">name</span><span class="o">:</span>    <span class="n">node</span><span class="o">.</span><span class="n">Fun</span><span class="o">.</span><span class="n">Name</span><span class="p">,</span>
			<span class="n">node</span><span class="o">:</span>    <span class="n">node</span><span class="p">,</span>
			<span class="n">fetcher</span><span class="o">:</span> <span class="o">&amp;</span><span class="n">VIPFetcher</span><span class="p">{},</span>
			<span class="n">matcher</span><span class="o">:</span> <span class="n">matcher</span><span class="p">,</span>
		<span class="p">},</span> <span class="no">nil</span>
	<span class="k">case</span> <span class="s">"req_vip_range"</span><span class="o">:</span>
		<span class="c">// ...</span>
  <span class="p">}</span>
</code></pre></div></div>

<p>有兴趣可以看看具体Matcher和Fetcher的实现。</p>

<h3 id="监控">监控</h3>

<p><strong>准备</strong></p>

<ul>
  <li>参考章节：
    <ul>
      <li><a href="https://github.com/baidu/bfe-book/blob/version1/design/monitor/monitor.md">监控机制</a></li>
      <li><a href="https://github.com/baidu/bfe-book/blob/version1/design/monitor/monitor.md">如何开发BFE扩展模块</a></li>
    </ul>
  </li>
  <li>go <a href="https://juejin.cn/post/6844904053042839560">atomic包</a></li>
  <li>go反射</li>
</ul>

<p>本节我们仍旧以<code class="language-plaintext highlighter-rouge">mod_waf</code>的实现为例，进行学习。</p>

<p><strong>实现机制</strong></p>

<p><a href="https://github.com/baidu/bfe-book/blob/version1/design/monitor/monitor.md">监控机制</a>一节一共讨论了2种监控方法：</p>

<ul>
  <li>基于日志监控：
    <ul>
      <li>打印日志，监控日志内容。</li>
      <li>优点：信息完善。缺点：耗资源 -&gt; IO操作，读取、解析、匹配…</li>
    </ul>
  </li>
  <li>维护内部状态：每秒处理请求数、并发连接数、命中策略数…</li>
</ul>

<p>bfe的服务状态信息(如上)，是基于内存进行统计(metrics)，并依赖一个web server(后台协程)对外暴露。这就引出了本节讨论的2个主要模块<code class="language-plaintext highlighter-rouge">metrics</code>和<code class="language-plaintext highlighter-rouge">web_monitor</code>。</p>

<p>首先，<code class="language-plaintext highlighter-rouge">metrics</code>实现了基于内存的服务状态存储和计算</p>

<ul>
  <li>服务状态分为<code class="language-plaintext highlighter-rouge">Counter</code>/<code class="language-plaintext highlighter-rouge">Gauge</code>/<code class="language-plaintext highlighter-rouge">State</code>三类，它们使用go语言的<code class="language-plaintext highlighter-rouge">atomic</code>机制保证操作的原子性。</li>
  <li><code class="language-plaintext highlighter-rouge">MetricsData</code>基于通过互斥锁(<code class="language-plaintext highlighter-rouge">Mutex</code>)实现了<code class="language-plaintext highlighter-rouge">Diff</code>接口，用于计算每个<code class="language-plaintext highlighter-rouge">interval</code>之间的数据变化。例如：最近20s内的请求pv。</li>
  <li><code class="language-plaintext highlighter-rouge">Metrics</code>对象负责实现服务状态的UI。用户可以基于上述3类服务状态定义任意形式的结构体(即<code class="language-plaintext highlighter-rouge">metricStruct</code>)，<code class="language-plaintext highlighter-rouge">Metrics</code>内部通过go反射来解析这个结构体。</li>
</ul>

<p>这段代码展示了<code class="language-plaintext highlighter-rouge">Metrics</code>是如何利用go反射，将用户定义的任意由<code class="language-plaintext highlighter-rouge">Counter/Gauge/State</code>三类状态组合成的结构体<code class="language-plaintext highlighter-rouge">metricStruct</code>，解析成内部数据结构的。</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">// initMetrics initializes metrics struct</span>
<span class="k">func</span> <span class="p">(</span><span class="n">m</span> <span class="o">*</span><span class="n">Metrics</span><span class="p">)</span> <span class="n">initMetrics</span><span class="p">(</span><span class="n">s</span> <span class="k">interface</span><span class="p">{})</span> <span class="p">{</span>
	<span class="n">m</span><span class="o">.</span><span class="n">counterMap</span> <span class="o">=</span> <span class="nb">make</span><span class="p">(</span><span class="k">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="o">*</span><span class="n">Counter</span><span class="p">)</span>
	<span class="n">m</span><span class="o">.</span><span class="n">gaugeMap</span> <span class="o">=</span> <span class="nb">make</span><span class="p">(</span><span class="k">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="o">*</span><span class="n">Gauge</span><span class="p">)</span>
	<span class="n">m</span><span class="o">.</span><span class="n">stateMap</span> <span class="o">=</span> <span class="nb">make</span><span class="p">(</span><span class="k">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="o">*</span><span class="n">State</span><span class="p">)</span>

	<span class="c">// 利用反射，获取s中变量的type和value</span>
	<span class="n">t</span> <span class="o">:=</span> <span class="n">reflect</span><span class="o">.</span><span class="n">TypeOf</span><span class="p">(</span><span class="n">s</span><span class="p">)</span><span class="o">.</span><span class="n">Elem</span><span class="p">()</span>
	<span class="n">v</span> <span class="o">:=</span> <span class="n">reflect</span><span class="o">.</span><span class="n">ValueOf</span><span class="p">(</span><span class="n">s</span><span class="p">)</span><span class="o">.</span><span class="n">Elem</span><span class="p">()</span>

	<span class="c">// 对每个变量进行遍历。实际上，每个变量即时用户想要维护的一个内部状态。</span>
	<span class="k">for</span> <span class="n">i</span> <span class="o">:=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">v</span><span class="o">.</span><span class="n">NumField</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="n">field</span> <span class="o">:=</span> <span class="n">t</span><span class="o">.</span><span class="n">Field</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
		<span class="n">value</span> <span class="o">:=</span> <span class="n">v</span><span class="o">.</span><span class="n">Field</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>

		<span class="c">// track created counters</span>
		<span class="n">name</span> <span class="o">:=</span> <span class="n">m</span><span class="o">.</span><span class="n">convert</span><span class="p">(</span><span class="n">field</span><span class="o">.</span><span class="n">Name</span><span class="p">)</span>

		<span class="c">// 对s中变量类型进行枚举，它必然是Counter/Gauge/State</span>
		<span class="k">switch</span> <span class="n">mType</span> <span class="o">:=</span> <span class="n">field</span><span class="o">.</span><span class="n">Type</span><span class="o">.</span><span class="n">Elem</span><span class="p">()</span><span class="o">.</span><span class="n">Name</span><span class="p">();</span> <span class="n">mType</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">TypeState</span><span class="o">:</span>
			<span class="n">v</span> <span class="o">:=</span> <span class="nb">new</span><span class="p">(</span><span class="n">State</span><span class="p">)</span>
			<span class="n">m</span><span class="o">.</span><span class="n">stateMap</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span>
			<span class="n">value</span><span class="o">.</span><span class="n">Set</span><span class="p">(</span><span class="n">reflect</span><span class="o">.</span><span class="n">ValueOf</span><span class="p">(</span><span class="n">v</span><span class="p">))</span>

		<span class="k">case</span> <span class="n">TypeCounter</span><span class="o">:</span>
			<span class="n">v</span> <span class="o">:=</span> <span class="nb">new</span><span class="p">(</span><span class="n">Counter</span><span class="p">)</span>
			<span class="n">m</span><span class="o">.</span><span class="n">counterMap</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span>
			<span class="n">value</span><span class="o">.</span><span class="n">Set</span><span class="p">(</span><span class="n">reflect</span><span class="o">.</span><span class="n">ValueOf</span><span class="p">(</span><span class="n">v</span><span class="p">))</span>

		<span class="k">case</span> <span class="n">TypeGauge</span><span class="o">:</span>
			<span class="n">v</span> <span class="o">:=</span> <span class="nb">new</span><span class="p">(</span><span class="n">Gauge</span><span class="p">)</span>
			<span class="n">m</span><span class="o">.</span><span class="n">gaugeMap</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span>
			<span class="n">value</span><span class="o">.</span><span class="n">Set</span><span class="p">(</span><span class="n">reflect</span><span class="o">.</span><span class="n">ValueOf</span><span class="p">(</span><span class="n">v</span><span class="p">))</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>其次，<code class="language-plaintext highlighter-rouge">web_monitor</code>实现了对外暴露数据的后台web server,比较简单：</p>

<ul>
  <li>基于go标准http包，其中<code class="language-plaintext highlighter-rouge">webHandler</code>是<code class="language-plaintext highlighter-rouge">http.Handler</code>接口的具体实现。</li>
  <li>接口路由基于2层map实现。第一层通过<code class="language-plaintext highlighter-rouge">WebHandlerType</code>进行枚举，第二层直接用key查询。</li>
  <li><code class="language-plaintext highlighter-rouge">RegisterHandler</code>接口实现回调注册。</li>
</ul>

<p>最后，我们来看一下<code class="language-plaintext highlighter-rouge">mod_waf</code>是如何依靠上述2个模块实现监控的。在<a href="#模块插件机制">模块插件机制</a>一节中我们知道<code class="language-plaintext highlighter-rouge">ModuleWafState</code>用于维护waf模块的内部状态，它分别关联了1个<code class="language-plaintext highlighter-rouge">Metrics</code>对象和全局<code class="language-plaintext highlighter-rouge">WebMonitor</code>对象。</p>

<p>定义模块自身的内部状态结构体：</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="n">ModuleWafState</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="n">CheckedReq</span> <span class="o">*</span><span class="n">metrics</span><span class="o">.</span><span class="n">Counter</span> <span class="c">// record how many requests check waf rule</span>

	<span class="n">HitBlockedReq</span>  <span class="o">*</span><span class="n">metrics</span><span class="o">.</span><span class="n">Counter</span> <span class="c">// record how many requests check waf rule</span>
	<span class="n">HitCheckedRule</span> <span class="o">*</span><span class="n">metrics</span><span class="o">.</span><span class="n">Counter</span> <span class="c">// hit checked rule</span>

	<span class="n">BlockedRuleError</span> <span class="o">*</span><span class="n">metrics</span><span class="o">.</span><span class="n">Counter</span> <span class="c">//err times of check blocked rule</span>
	<span class="n">CheckedRuleError</span> <span class="o">*</span><span class="n">metrics</span><span class="o">.</span><span class="n">Counter</span> <span class="c">// err times of check checked rule</span>
<span class="p">}</span>
</code></pre></div></div>

<p>实现暴露状态数据的回调接口，并在<code class="language-plaintext highlighter-rouge">Init</code>接口中向<code class="language-plaintext highlighter-rouge">WebMonitor</code>注册：</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="p">(</span><span class="n">m</span> <span class="o">*</span><span class="n">ModuleWaf</span><span class="p">)</span> <span class="n">Init</span><span class="p">(</span><span class="n">cbs</span> <span class="o">*</span><span class="n">bfe_module</span><span class="o">.</span><span class="n">BfeCallbacks</span><span class="p">,</span> <span class="n">whs</span> <span class="o">*</span><span class="n">web_monitor</span><span class="o">.</span><span class="n">WebHandlers</span><span class="p">,</span> <span class="n">cr</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
	<span class="c">// ...</span>

	<span class="c">// 监控相关</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">web_monitor</span><span class="o">.</span><span class="n">RegisterHandlers</span><span class="p">(</span><span class="n">whs</span><span class="p">,</span> <span class="n">web_monitor</span><span class="o">.</span><span class="n">WebHandleMonitor</span><span class="p">,</span> <span class="n">m</span><span class="o">.</span><span class="n">monitorHandlers</span><span class="p">())</span>
	<span class="k">if</span> <span class="n">err</span> <span class="o">!=</span> <span class="no">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="n">fmt</span><span class="o">.</span><span class="n">Errorf</span><span class="p">(</span><span class="s">"%s.Init(): RegisterHandlers(m.monitorHandlers): %v"</span><span class="p">,</span> <span class="n">m</span><span class="o">.</span><span class="n">Name</span><span class="p">(),</span> <span class="n">err</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="c">// ...</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="日志">日志</h3>

<p><strong>准备</strong></p>

<ul>
  <li>参考章节：<a href="https://github.com/baidu/bfe-book/blob/version1/design/log/log.md">日志机制</a></li>
</ul>

<p><strong>实现机制</strong></p>

<p>首先，BFE对于不同用途的日志做出明确区分，这点是值得重视的。日志本身实现难度并不大，但是很多业务中的日志却是五花八门，个人觉得大多时候都是设计上的懒惰。</p>

<p>我们主要看 <em>访问日志(access log)</em>。它被实现为一个模块<code class="language-plaintext highlighter-rouge">mod_access</code>，实现方法我们已经在<code class="language-plaintext highlighter-rouge">mod_waf</code>介绍过了，它们大体相同。这里直接看回调代码：</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="p">(</span><span class="n">m</span> <span class="o">*</span><span class="n">ModuleAccess</span><span class="p">)</span> <span class="n">requestLogHandler</span><span class="p">(</span><span class="n">req</span> <span class="o">*</span><span class="n">bfe_basic</span><span class="o">.</span><span class="n">Request</span><span class="p">,</span> <span class="n">res</span> <span class="o">*</span><span class="n">bfe_http</span><span class="o">.</span><span class="n">Response</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="n">byteStr</span> <span class="o">:=</span> <span class="n">bytes</span><span class="o">.</span><span class="n">NewBuffer</span><span class="p">(</span><span class="no">nil</span><span class="p">)</span>

	<span class="c">// 这一段是在拼装access日志</span>
	<span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">item</span> <span class="o">:=</span> <span class="k">range</span> <span class="n">m</span><span class="o">.</span><span class="n">reqFmts</span> <span class="p">{</span>
		<span class="k">switch</span> <span class="n">item</span><span class="o">.</span><span class="n">Type</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">FormatString</span><span class="o">:</span>
			<span class="n">byteStr</span><span class="o">.</span><span class="n">WriteString</span><span class="p">(</span><span class="n">item</span><span class="o">.</span><span class="n">Key</span><span class="p">)</span>
		<span class="k">case</span> <span class="n">FormatTime</span><span class="o">:</span>
			<span class="n">onLogFmtTime</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">byteStr</span><span class="p">)</span>
		<span class="k">default</span><span class="o">:</span>
			<span class="c">// fmtHandlerTable这个表里存储了item.Type和对应信息的获取方法</span>
			<span class="n">handler</span><span class="p">,</span> <span class="n">found</span> <span class="o">:=</span> <span class="n">fmtHandlerTable</span><span class="p">[</span><span class="n">item</span><span class="o">.</span><span class="n">Type</span><span class="p">]</span>
			<span class="k">if</span> <span class="n">found</span> <span class="p">{</span>
				<span class="n">h</span> <span class="o">:=</span> <span class="n">handler</span><span class="o">.</span><span class="p">(</span><span class="k">func</span><span class="p">(</span><span class="o">*</span><span class="n">ModuleAccess</span><span class="p">,</span> <span class="o">*</span><span class="n">LogFmtItem</span><span class="p">,</span> <span class="o">*</span><span class="n">bytes</span><span class="o">.</span><span class="n">Buffer</span><span class="p">,</span>
					<span class="o">*</span><span class="n">bfe_basic</span><span class="o">.</span><span class="n">Request</span><span class="p">,</span> <span class="o">*</span><span class="n">bfe_http</span><span class="o">.</span><span class="n">Response</span><span class="p">)</span> <span class="kt">error</span><span class="p">)</span>
				<span class="n">h</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">item</span><span class="p">,</span> <span class="n">byteStr</span><span class="p">,</span> <span class="n">req</span><span class="p">,</span> <span class="n">res</span><span class="p">)</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="c">// 这里是实际打印日志，详见log4go</span>
	<span class="n">m</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">Info</span><span class="p">(</span><span class="n">byteStr</span><span class="o">.</span><span class="n">String</span><span class="p">())</span>

	<span class="k">return</span> <span class="n">bfe_module</span><span class="o">.</span><span class="n">BfeHandlerGoOn</span>
<span class="p">}</span>
</code></pre></div></div>

<p>其次，我们简单学习一下<em>log4go</em>这个包。代码结构如下：</p>

<p><span style="display:block;text-align:center"><img src="/images/bfe/uml_log4go.png" alt="log4go代码结构" /></span></p>
<div style="font-size:14px;text-align:center">log4go代码结构</div>

<p>log4go的主要设计是基于<code class="language-plaintext highlighter-rouge">chan</code>来异步写日志，即：用户只负责向<code class="language-plaintext highlighter-rouge">chan</code>中分发日志(消息)，log4go通过后台协程去消费这个<code class="language-plaintext highlighter-rouge">chan</code>中的数据，串行地向日志文件中进行写操作。</p>

<p>实现上，核心接口是<code class="language-plaintext highlighter-rouge">LogWriter</code>和<code class="language-plaintext highlighter-rouge">LogCloser</code>，前者负责用户<em>写日志</em>操作，后者负责关闭日志。</p>

<p><code class="language-plaintext highlighter-rouge">TimeFileLogWriter</code>是一个具体的实现。首先看下初始化消费协程的逻辑：</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="n">NewTimeFileLogWriter</span><span class="p">(</span><span class="n">fname</span> <span class="kt">string</span><span class="p">,</span> <span class="n">when</span> <span class="kt">string</span><span class="p">,</span> <span class="n">backupCount</span> <span class="kt">int</span><span class="p">,</span> <span class="n">enableCompress</span> <span class="kt">bool</span><span class="p">)</span> <span class="o">*</span><span class="n">TimeFileLogWriter</span> <span class="p">{</span>
	<span class="c">// ...</span>

	<span class="c">// 开启后台协程，真正向文件中写入日志。这样所有写入操作都是串行的。</span>
	<span class="k">go</span> <span class="k">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="k">defer</span> <span class="k">func</span><span class="p">()</span> <span class="p">{</span>
			<span class="k">if</span> <span class="n">w</span><span class="o">.</span><span class="n">file</span> <span class="o">!=</span> <span class="no">nil</span> <span class="p">{</span>
				<span class="n">w</span><span class="o">.</span><span class="n">file</span><span class="o">.</span><span class="n">Close</span><span class="p">()</span>
			<span class="p">}</span>
		<span class="p">}()</span>

		<span class="k">for</span> <span class="n">rec</span> <span class="o">:=</span> <span class="k">range</span> <span class="n">w</span><span class="o">.</span><span class="n">rec</span> <span class="p">{</span>
			<span class="c">// 检查一下消息是否为终止信号</span>
			<span class="k">if</span> <span class="n">w</span><span class="o">.</span><span class="n">EndNotify</span><span class="p">(</span><span class="n">rec</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">return</span>
			<span class="p">}</span>

			<span class="c">// 日志切分处理</span>
			<span class="k">if</span> <span class="n">w</span><span class="o">.</span><span class="n">shouldRollover</span><span class="p">()</span> <span class="p">{</span>
				<span class="k">if</span> <span class="n">err</span> <span class="o">:=</span> <span class="n">w</span><span class="o">.</span><span class="n">intRotate</span><span class="p">();</span> <span class="n">err</span> <span class="o">!=</span> <span class="no">nil</span> <span class="p">{</span>
					<span class="n">fmt</span><span class="o">.</span><span class="n">Fprintf</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">Stderr</span><span class="p">,</span> <span class="s">"NewTimeFileLogWriter(%q): %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">w</span><span class="o">.</span><span class="n">filename</span><span class="p">,</span> <span class="n">err</span><span class="p">)</span>
					<span class="k">continue</span>
				<span class="p">}</span>
			<span class="p">}</span>

			<span class="c">// Perform the write</span>
			<span class="k">var</span> <span class="n">err</span> <span class="kt">error</span>
			<span class="k">if</span> <span class="n">rec</span><span class="o">.</span><span class="n">Binary</span> <span class="o">!=</span> <span class="no">nil</span> <span class="p">{</span>
				<span class="n">_</span><span class="p">,</span> <span class="n">err</span> <span class="o">=</span> <span class="n">w</span><span class="o">.</span><span class="n">file</span><span class="o">.</span><span class="n">Write</span><span class="p">(</span><span class="n">rec</span><span class="o">.</span><span class="n">Binary</span><span class="p">)</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="n">_</span><span class="p">,</span> <span class="n">err</span> <span class="o">=</span> <span class="n">fmt</span><span class="o">.</span><span class="n">Fprint</span><span class="p">(</span><span class="n">w</span><span class="o">.</span><span class="n">file</span><span class="p">,</span> <span class="n">FormatLogRecord</span><span class="p">(</span><span class="n">w</span><span class="o">.</span><span class="n">format</span><span class="p">,</span> <span class="n">rec</span><span class="p">))</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="n">err</span> <span class="o">!=</span> <span class="no">nil</span> <span class="p">{</span>
				<span class="n">fmt</span><span class="o">.</span><span class="n">Fprintf</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">Stderr</span><span class="p">,</span> <span class="s">"NewTimeFileLogWriter(%q): %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">w</span><span class="o">.</span><span class="n">filename</span><span class="p">,</span> <span class="n">err</span><span class="p">)</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}()</span>

	<span class="k">return</span> <span class="n">w</span>
<span class="p">}</span>
</code></pre></div></div>

<p>终止信号是什么呢？我们先看下<code class="language-plaintext highlighter-rouge">LogWrite</code>接口中<code class="language-plaintext highlighter-rouge">Close</code>，以及<code class="language-plaintext highlighter-rouge">LogClose</code>接口的具体实现：</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">// Close waits for dump all log and close chan</span>
<span class="k">func</span> <span class="p">(</span><span class="n">w</span> <span class="o">*</span><span class="n">TimeFileLogWriter</span><span class="p">)</span> <span class="n">Close</span><span class="p">()</span> <span class="p">{</span>
	<span class="n">w</span><span class="o">.</span><span class="n">WaitForEnd</span><span class="p">(</span><span class="n">w</span><span class="o">.</span><span class="n">rec</span><span class="p">)</span>
	<span class="nb">close</span><span class="p">(</span><span class="n">w</span><span class="o">.</span><span class="n">rec</span><span class="p">)</span>
<span class="p">}</span>

<span class="c">// notyfy the logger log to end</span>
<span class="k">func</span> <span class="p">(</span><span class="n">lc</span> <span class="o">*</span><span class="n">LogCloser</span><span class="p">)</span> <span class="n">EndNotify</span><span class="p">(</span><span class="n">lr</span> <span class="o">*</span><span class="n">LogRecord</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="k">if</span> <span class="n">lr</span> <span class="o">==</span> <span class="no">nil</span> <span class="o">&amp;&amp;</span> <span class="n">lc</span><span class="o">.</span><span class="n">IsEnd</span> <span class="o">!=</span> <span class="no">nil</span> <span class="p">{</span>
		<span class="n">lc</span><span class="o">.</span><span class="n">IsEnd</span> <span class="o">&lt;-</span> <span class="no">true</span>
		<span class="k">return</span> <span class="no">true</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="no">false</span>
<span class="p">}</span>

<span class="c">// add nil to end of res and wait that EndNotify is call</span>
<span class="k">func</span> <span class="p">(</span><span class="n">lc</span> <span class="o">*</span><span class="n">LogCloser</span><span class="p">)</span> <span class="n">WaitForEnd</span><span class="p">(</span><span class="n">rec</span> <span class="k">chan</span> <span class="o">*</span><span class="n">LogRecord</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">rec</span> <span class="o">&lt;-</span> <span class="no">nil</span>
	<span class="k">if</span> <span class="n">lc</span><span class="o">.</span><span class="n">IsEnd</span> <span class="o">!=</span> <span class="no">nil</span> <span class="p">{</span>
		<span class="o">&lt;-</span><span class="n">lc</span><span class="o">.</span><span class="n">IsEnd</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>不难发现，实际上是传入一个<code class="language-plaintext highlighter-rouge">nil</code>对象(<code class="language-plaintext highlighter-rouge">LogRecord</code>类型)。后台协程通过<code class="language-plaintext highlighter-rouge">EndNotify</code>获取到<code class="language-plaintext highlighter-rouge">nil</code>终止信号，向<code class="language-plaintext highlighter-rouge">lc.IsEnd</code>通道内发出终止标记，并直接返回结束；主协程通过<code class="language-plaintext highlighter-rouge">WairForEnd</code>阻塞在<code class="language-plaintext highlighter-rouge">&lt;-lc.IsEnd</code>这里，一旦收到后台协程发出的终止标记后，即表示剩余日志完成处理，关闭日志通道<code class="language-plaintext highlighter-rouge">w.rec</code>。</p>

<h3 id="其它">其它</h3>

<ul>
  <li>优雅重启
    <ul>
      <li>向监听协程发出close信号，<code class="language-plaintext highlighter-rouge">bfe_server.Serve</code>捕获信号后等待超时并终止<code class="language-plaintext highlighter-rouge">Accept</code>。</li>
      <li>开启同步协程，等待所有连接的处理协程结束(使用<code class="language-plaintext highlighter-rouge">WaitGroup</code>)，然后发出结束通知；同时开启超时协程(使用<code class="language-plaintext highlighter-rouge">time.After</code>)。</li>
      <li>循环监听同步协程和超时协程，直到有一个发生后，结束服务。</li>
    </ul>
  </li>
</ul>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">// ShutdownHandler is signal handler for QUIT</span>
<span class="k">func</span> <span class="p">(</span><span class="n">srv</span> <span class="o">*</span><span class="n">BfeServer</span><span class="p">)</span> <span class="n">ShutdownHandler</span><span class="p">(</span><span class="n">sig</span> <span class="n">os</span><span class="o">.</span><span class="n">Signal</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">shutdownTimeout</span> <span class="o">:=</span> <span class="n">srv</span><span class="o">.</span><span class="n">Config</span><span class="o">.</span><span class="n">Server</span><span class="o">.</span><span class="n">GracefulShutdownTimeout</span>
	<span class="n">log</span><span class="o">.</span><span class="n">Logger</span><span class="o">.</span><span class="n">Info</span><span class="p">(</span><span class="s">"get signal %s, graceful shutdown in %ds"</span><span class="p">,</span> <span class="n">sig</span><span class="p">,</span> <span class="n">shutdownTimeout</span><span class="p">)</span>

	<span class="c">// notify that server is in graceful shutdown state</span>
	<span class="nb">close</span><span class="p">(</span><span class="n">srv</span><span class="o">.</span><span class="n">CloseNotifyCh</span><span class="p">)</span>

	<span class="c">// close server listeners</span>
	<span class="n">srv</span><span class="o">.</span><span class="n">closeListeners</span><span class="p">()</span>

	<span class="c">// waits server conns to finish</span>
	<span class="n">connFinCh</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="k">chan</span> <span class="kt">bool</span><span class="p">)</span>
	<span class="k">go</span> <span class="k">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="n">srv</span><span class="o">.</span><span class="n">connWaitGroup</span><span class="o">.</span><span class="n">Wait</span><span class="p">()</span>
		<span class="n">connFinCh</span> <span class="o">&lt;-</span> <span class="no">true</span>
	<span class="p">}()</span>

	<span class="n">shutdownTimer</span> <span class="o">:=</span> <span class="n">time</span><span class="o">.</span><span class="n">After</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">Duration</span><span class="p">(</span><span class="n">shutdownTimeout</span><span class="p">)</span> <span class="o">*</span> <span class="n">time</span><span class="o">.</span><span class="n">Second</span><span class="p">)</span>

<span class="n">Loop</span><span class="o">:</span>
	<span class="k">for</span> <span class="p">{</span>
		<span class="k">select</span> <span class="p">{</span>
		<span class="c">// waits server conns to finish</span>
		<span class="k">case</span> <span class="o">&lt;-</span><span class="n">connFinCh</span><span class="o">:</span>
			<span class="n">log</span><span class="o">.</span><span class="n">Logger</span><span class="o">.</span><span class="n">Info</span><span class="p">(</span><span class="s">"graceful shutdown success."</span><span class="p">)</span>
			<span class="k">break</span> <span class="n">Loop</span>

		<span class="c">// wait for shutdown timeout</span>
		<span class="k">case</span> <span class="o">&lt;-</span><span class="n">shutdownTimer</span><span class="o">:</span>
			<span class="n">log</span><span class="o">.</span><span class="n">Logger</span><span class="o">.</span><span class="n">Info</span><span class="p">(</span><span class="s">"graceful shutdown timeout."</span><span class="p">)</span>
			<span class="k">break</span> <span class="n">Loop</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="c">// shutdown server</span>
	<span class="n">log</span><span class="o">.</span><span class="n">Logger</span><span class="o">.</span><span class="n">Close</span><span class="p">()</span>
	<span class="n">os</span><span class="o">.</span><span class="n">Exit</span><span class="p">(</span><span class="m">0</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="美团">美团</h2>

<p>没看到有开源的，因此仅对官方技术文档做一个整理。</p>

<h3 id="概述-2">概述</h3>

<p><span style="display:block;text-align:center"><img src="/images/api_gateway/美团API网关整体架构.jpeg" alt="美团API网关整体架构" /></span></p>
<div style="font-size:14px;text-align:center">美团API网关整体架构</div>

<p>如图，整体架构主要包括2个部分：</p>

<ul>
  <li><a href="https://tech.meituan.com/2018/09/06/oceanus-custom-traffic-routing.html">Oceanus</a>：相当于美团统一前端，负责将流量转发到业务集群。</li>
  <li><a href="https://mp.weixin.qq.com/s/iITqdIiHi3XGKq6u6FRVdg">Shepherd</a>：对业务线API Gateway需求进行了抽象，以服务(API管理)和SDK的形式输出能力。</li>
</ul>

<p>以下进行展开介绍。</p>

<p><strong>Oceanus</strong></p>

<p>这个材料里面我们只能看到定制化路由这部分，关于安全、登陆等常见功能并未做介绍。</p>

<ul>
  <li>基于<em>OpenResty</em>开发实现。</li>
  <li>策略查询：<code class="language-plaintext highlighter-rouge">Host+location_path</code> &amp; <code class="language-plaintext highlighter-rouge">appkey</code></li>
  <li>策略规则设计：<code class="language-plaintext highlighter-rouge">condition</code>支持简单的规则引擎。</li>
  <li>策略更新：使用worker进程间的共享内存，定时更新。</li>
</ul>

<p><span style="display:block;text-align:center"><img src="/images/api_gateway/Oceanus策略查询设计.png" alt="Oceanus策略查询设计" height="80%" width="80%" /></span></p>
<div style="font-size:14px;text-align:center">Oceanus策略查询设计</div>

<p><span style="display:block;text-align:center"><img src="/images/api_gateway/Oceanus策略规则设计.png" alt="Oceanus策略查询设计" /></span></p>
<div style="font-size:14px;text-align:center">Oceanus策略规则设计</div>

<p><strong>Shepherd</strong></p>

<ul>
  <li>服务编排：依托公司内部自研的编排中间件 <a href="https://mp.weixin.qq.com/s?__biz=MjM5NjQ5MTI5OA==&amp;mid=2651748475&amp;idx=3&amp;sn=23b517c9c5173a6585ddc7bfd23a878a&amp;chksm=bd12a1368a65282071cec8ce73f16f86de546b2e22eae0af46cd8b6b88521b2ed14e32fb32e9&amp;scene=21#wechat_redirect">海盗</a>。</li>
</ul>

<h2 id="traefik">Traefik</h2>

                    </section>
                </div><div class="search-results">
    <div class="has-results">
        <h1 class="search-results-title"><span class='search-results-count'></span> results matching "<span class='search-query'></span>"</h1>
        <ul class="search-results-list"></ul>
    </div>
    <div class="no-results">
        <h1 class="search-results-title">No results matching "<span class='search-query'></span>"</h1>
    </div>
</div></div>
        </div>
    </div>
</div>

                    <a href="/jekyll/2019-04-29-license.html" class="navigation navigation-prev navigation-unique" aria-label="Previous page: License">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
            </div>

            <script>
            var gitbook = gitbook || [];
            gitbook.push(function() {
                gitbook.page.hasChanged({
    "page": {
        "title": "Introduction",
        "level": "1.1",
        "depth": 1,
        
        "dir": "ltr"
    },    "config": {
        "plugins": ["fontsettings", "highlight", "livereload", "lunr", "search", "sharing", "theme-default", "livereload"],
        "styles": {
            "ebook": "styles/ebook.css",
            "epub": "styles/epub.css",
            "mobi": "styles/mobi.css",
            "pdf": "styles/pdf.css",
            "print": "styles/print.css",
            "website": "styles/website.css"
        },
        "pluginsConfig": {
            "fontsettings": {
                "family": "sans",
                "size": 2,
                "theme": "white"
            },
            "highlight": {},
            "livereload": {},
            "lunr": {
                "ignoreSpecialCharacters": false,
                "maxIndexSize": 1000000
            },
            "search": {},
            "sharing": {
                "all": ["facebook", "google", "twitter", "weibo", "instapaper"],
                "facebook": true,
                "google": false,
                "instapaper": false,
                "twitter": true,
                "vk": false,
                "weibo": false
            },
            "theme-default": {
                "showLevel": false,
                "styles": {
                    "ebook": "styles/ebook.css",
                    "epub": "styles/epub.css",
                    "mobi": "styles/mobi.css",
                    "pdf": "styles/pdf.css",
                    "print": "styles/print.css",
                    "website": "styles/website.css"
                }
            }
        },
        "theme": "default",
        "author": "Tao He",
        "pdf": {
            "pageNumbers": true,
            "fontSize": 12,
            "fontFamily": "Arial",
            "paperSize": "a4",
            "chapterMark": "pagebreak",
            "pageBreaksBefore": "/",
            "margin": {
                "right": 62,
                "left": 62,
                "top": 56,
                "bottom": 56
            }
        },
        "structure": {
            "langs": "LANGS.md",
            "readme": "README.md",
        },
        "variables": {},
        "title": "tjufc's blog",
        "language": "en",
        "gitbook": "*"
    },
    "file": {
        "path": "_posts/2022-02-05-api-gateway.md",
        "mtime": "2022-02-05 00:00:00 +0800",
        "type": "markdown"
    },
    "gitbook": {
        "version": "3.2.3",
        "time": "2022-02-05 18:39:22 +0800"
    },
    "basePath": "",
    "book": {
        "language": ""
    }
});
            });
            </script>
        </div><script src="/gitbook/gitbook.js"></script>
<script src="/gitbook/theme.js"></script>

<script src="/gitbook/gitbook-plugin-fontsettings/fontsettings.js"></script>
<script src="/gitbook/gitbook-plugin-sharing/buttons.js"></script>

<!-- <script src="../gitbook/gitbook-plugin-lunr/lunr.min.js"></script>
<script src="../gitbook/gitbook-plugin-lunr/search-lunr.js"></script>
<script src="../gitbook/gitbook-plugin-search/search-engine.js"></script>
<script src="../gitbook/gitbook-plugin-search/search.js"></script> -->

<script src="/gitbook/gitbook-plugin-search-pro/jquery.mark.min.js"></script>
<script src="/gitbook/gitbook-plugin-search-pro/search.js"></script>

<script type="text/javascript" id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"></script>
</body>
</html>